import random
import sys
import os

def generate_clause(n_vars, length):
    vars_in_clause = random.sample(range(1, n_vars + 1), length)
    return [random.choice([-1, 1]) * var for var in vars_in_clause]

def get_unique_filename(folder, tag):
    os.makedirs(folder, exist_ok=True)
    index = 0
    while True:
        filename = os.path.join(folder, f"{tag}_{index:03d}.cnf")
        if not os.path.exists(filename):
            return filename
        index += 1

def generate_input_file(n_vars, n_clauses, min_clause_len=None, fixed_clause_len=None,
                        unsat_chance=0.0, folder='inputs'):
    clause_len_desc = (
        f"exact{fixed_clause_len}" if fixed_clause_len else
        f"range{min_clause_len}_to_{n_vars}" if min_clause_len else
        f"rand1_to_{n_vars}"
    )
    tag_suffix = f"vars{n_vars}_clauses{n_clauses}_{clause_len_desc}_unsat{unsat_chance:.2f}"
    filename = get_unique_filename(folder, f"input_{tag_suffix}")

    with open(filename, 'w') as f:
        f.write(f"c CNF formula generated by generate_input.py\n")
        f.write(f"c Number of variables: {n_vars}\n")
        f.write(f"c Intended number of clauses: {n_clauses}\n")
        f.write(f"c Clause length mode: {clause_len_desc}\n")
        f.write(f"c Unsatisfiability injection chance: {unsat_chance}\n")

        actual_clauses = []

        for _ in range(n_clauses):
            if unsat_chance > 0.0 and random.random() < unsat_chance:
                var = random.randint(1, n_vars)
                actual_clauses.append([var])
                actual_clauses.append([-var])
            else:
                length = (
                    fixed_clause_len if fixed_clause_len else
                    random.randint(min_clause_len, n_vars) if min_clause_len else
                    random.randint(1, n_vars)
                )
                actual_clauses.append(generate_clause(n_vars, length))

        f.write(f"p cnf {n_vars} {len(actual_clauses)}\n")
        for clause in actual_clauses:
            f.write(' '.join(map(str, clause)) + " 0\n")

    print(f"Generated: '{filename}' ({len(actual_clauses)} clauses)")

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description="CNF generator for DIMACS format.")
    parser.add_argument("n_vars", type=int, help="Number of variables")
    parser.add_argument("n_clauses", type=int, help="Number of base clauses")
    parser.add_argument("clause_mode", nargs="?", help="Clause mode: fixed:k or min length (int)")
    parser.add_argument("folder", nargs="?", default="inputs", help="Output folder")
    parser.add_argument("--unsat-chance", type=float, default=0.0, help="Chance to inject contradictions (0.0 to 1.0)")

    args = parser.parse_args()

    n_vars = args.n_vars
    n_clauses = args.n_clauses
    folder = args.folder
    unsat_chance = args.unsat_chance
    fixed_clause_len = None
    min_clause_len = None

    if args.clause_mode:
        if args.clause_mode.startswith("fixed:"):
            fixed_clause_len = int(args.clause_mode.split(":")[1])
        elif args.clause_mode.isdigit():
            min_clause_len = int(args.clause_mode)

    # Validation
    if n_vars <= 0 or n_clauses <= 0:
        sys.exit("Error: n_vars and n_clauses must be > 0")
    if fixed_clause_len and (fixed_clause_len <= 0 or fixed_clause_len > n_vars):
        sys.exit("Error: fixed clause length must be 1 <= k <= n_vars")
    if min_clause_len and (min_clause_len <= 0 or min_clause_len > n_vars):
        sys.exit("Error: min clause length must be 1 <= k <= n_vars")

    generate_input_file(n_vars, n_clauses, min_clause_len, fixed_clause_len, unsat_chance, folder)
